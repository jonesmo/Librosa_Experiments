# -*- coding: utf-8 -*-
"""chopping_Tim_Daisy_samples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BCz288ctF1kk0jE5bv8a8Z9S9fEUONep
"""

pip install pydub

# Commented out IPython magic to ensure Python compatibility.
#import everything
import numpy as np
import pandas as pd
import librosa
import librosa.display
import pydub
from pydub import AudioSegment
from pydub.playback import play
from matplotlib import pyplot as plt
# %matplotlib inline
import math
from numpy import mean
from numpy.random import randint
from scipy import stats
from numpy.random import seed
import IPython
import IPython.display
from IPython.display import Audio, display

import seaborn as sns
sns.set()

from google.colab import drive
drive.mount('/content/gdrive')

with open('/content/gdrive/My Drive/Music Coding/Chopping Audio/Free Kit_6.wav', 'rb') as wav_file:
  wav_data = wav_file.read()
  print(wav_data)

Daisy1, sr = librosa.load('/content/gdrive/My Drive/Music Coding/Chopping Audio/Free Kit_6.wav')

Audio(Daisy1, rate=sr)

plt.figure()
plt.plot(Daisy1, c='orange')
plt.show()

"""##Pick a Random Grain, Find Fun Grain Sizes"""

filelength = len(Daisy1)

starting_sample = np.random.randint(0, filelength)

grain_length = 10
ending_sample = starting_sample + grain_length

grain_0 = Daisy1[starting_sample:ending_sample]

Audio(grain_0, rate=sr)

"""##Now, figure out enveloping: rise, fall, neither, both

##Also now, repeat that one sample a bunch of times
"""

def grain_multiple_times(audio_data, num_times):
  current_audio = audio_data
  for i in range(0, num_times):
     = np.concatenate(current_audio)
  return audio_data

fifty_times = grain_multiple_times(grain_0, 50)